%!TEX root = ./main.tex


\section{Introduction}
\label{sec:introduction}

\emph{Process discovery} is one of the most investigated process mining techniques \cite{2012-Aalst}. It deals with the automatic learning of a process model from a given set of logged traces, each one representing the digital footprint of the execution of a case.

If we focus on the way process discovery techniques see the model-extraction task, we can divide them into two broad categories \cite{2018-Ponce}). The first category is constituted by works that tackle the problem of process discovery with one-class supervised learning techniques (see, e.g., \cite{2004-Aalst,2003-Weijters,2007-Gunther,2010-Aalst}). These works are driven by the assumption that all available log traces are instances of the process to be discovered. The second category comprises works that intend model-extraction as a two-class supervised task (\cite{2006-Maruster,2009-Goedertier,2009-Chesani}), which is driven by the possibility of partitioning the log traces into two sets according to some business or domain-related criterion. Usually these sets are referred to as \emph{positive} and \emph{negative} examples \cite{2018-Ponce}, and the goal is to learn a model that characterises one set w.r.t. the other. Hereafter, we refer to miners of the first and second category as \emph{unary} ands \emph{binary} miners, respectively. 

Traditionally, the vast majority of works in the process discovery spectrum have followed the first approach. Nonetheless, few recent works \cite{2018-Ponce,DBLP:conf/bpm/SlaatsDB21,deviant-arxiv} \tododl{se citiamo deviant con indicazione TKDE under review ci vale come citazione in scopus, altrimenti no} have highlighted the importance of addressing this challenge as a two-class supervised task with different motivations: first and foremost the actual existence of \emph{positive} and \emph{negative} examples in real use cases \cite{2018-Ponce,DBLP:conf/bpm/SlaatsDB21}; second, the need to balance \emph{accuracy} and \emph{recall} \cite{DBLP:conf/bpm/SlaatsDB21}; and the need to discover the process of a particular variant according to a domain-specific need (e.g., the process characterizing ``fast'' traces) against the one that characterizes other variants, thus using the concept of \emph{positive} and \emph{negative} as a way to distinguish between two classes of examples \cite{deviant-arxiv}.  

A problem that remains unsolved in process discovery in general and, in process discovery as a two-class supervised task in particular, is the need to select, among all possible discovered models, the ones that fit better the expectations of a user. This is somehow true for the traditional discovery of procedural and declarative models in a one-class supervised learning fashion, where the discovered model that accepts all the positive examples is usually too complex (e.g., too spaghetti like), and mechanisms are introduced to ``select'' different outputs. Examples of criteria for the selection can be the frequency of a certain behavior (e.g., an activity or a path), or the presence of certain modeling patterns (e.g., a specific Declare pattern).   
The problem becomes even more compelling when we approach process discovery as a two-class supervised task. In fact, as recently shown by \cite{DBLP:conf/bpm/SlaatsDB21}, perfect binary miners, able to discover models that accept all positive examples and none of the negative examples, do not necessarily exist.  
 
In this paper, we address the problem of inserting user preferences in the discovery of declarative process models  as a two-class supervised task. In particular we start from a recent work \cite{deviant-arxiv} that introduces the \nd binary miner for the \declare \cite{2009-Aalst} modeling language. We show how to extend it with preference mechanisms able to increase the role of the users in obtaining their preferred models, and we provide the following contributions: 
\begin{enumerate}[{(i)}]
	\item we retain the original preference mechanism of \nd, based on the notion of model subsumption, which enables to obtain models that vary in generality/specificity, or simplicity. These preference mechanisms are considered to be domain-independent as they work on general properties of the representation and do not affect the language used to represent the model. In other words, they do not introduce any language bias (or preference) in the representation of the process model (Section \ref{sec:deviant});
	\item we introduce two types of new preferences: the first one on the \declare patterns considered, and the second one on the activities appearing in the model. These new types of preferences introduce a clear language bias in the representation as they strongly affect the language that can be used to build the model, and are often grounded in domain dependent settings. Furthermore we show how to obtain new preferences by combining the two (Section \ref{sec:tool}); 
	\item we show how to extend \nd to incorporate the new preferences using an \ac{ASP} \cite{2008-Lifschitz} approach via the ASPrin tool \cite{DBLP:conf/aaai/BrewkaD0S15}.   
	\item We report on exploratory experiments applying an instantiation of \nd  to the data sets of \cite{DBLP:conf/bpm/SlaatsDB21} comparing results to ?????? \todo{cosa vogliamo far vedere nella valutazione? la faccimao?}.
\end{enumerate}


cardinalit√†...