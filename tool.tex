%!TEX root = ./main.tex

\section{Adding preferences to process discovery: an implementation through \asprin}
\label{sec:tool}

At first glance it looks like the ${\textit{\sheriff}}$ function includes all what we need to generate ``preferred'' models; that is, by selecting exactly one constraint from each ${\textit{\sheriff}}(t)\neq\emptyset$ for $t\in L^-$ according to some patterns that depend on the preferences. However, that's clearly not the case because constraints are not independent: e.g., some constraints are more general than others (i.e.\ they satisfy a bigger set of traces, see Def.~\ref{def:subs}), but there is also the case in which selecting two constraints implies the validity of a third one. For example, selecting $\mathsf{precedence(a,b)}$ and $\mathsf{response(a,b)}$ would be equivalent to select $\mathsf{succession(a,b)}$ as well.

For this reason we cannot use any combinatorial optimiser, but we need a system enabling some form of constraint propagation. In~\cite{deviant-tkde} an Answer Set Programming (ASP) has been used, by leveraging the underlying rule based formalism enabling propagation, and \emph{weak constraints}\footnote{Note that these constraints are not related to the Declare constraints mentioned above, they share the name because of their relation with mathematical logic. The same meaning overloading applies to the word ``model''.} for optimisation~\cite{asp-intro,clingo}. The encoding of the optimisation problem follows the \emph{Generate and Test} ASP paradigm where part of the rules select a candidate ASP model (e.g., a subset of $\mathcal{C}$) and a set of constraints filter only the relevant models (e.g., those ``rejecting'' all the negative examples). Weak constraints are used to assign a preference value to any ASP model; i.e., a violated weak constraint doesn't reject the model but assigns a penalty.
%
In~\cite{deviant-tkde}, simple weak constraints were used to implement subset based preferences; however, specifying more complex preferences between ASP models using constraints become unmanageble and error-prone. The \asprin tool~\cite{DBLP:conf/aaai/BrewkaD0S15} layers upon the \emph{clingo} ASP solver~\cite{clingo}, enabling the specification of complex preference relations through user-defined  types and their arguments. By exploiting this flexibility we can capture the different types of preferences identified in Section~\ref{sec:example}.

\asprin provides a general framework for optimising qualitative and quantitative preferences in ASP. It allows for computing optimal answer sets of logic programs with preferences. While \asprin comes with a library of predefined preference types (subset, pareto, lexicographic, etc.), it is readily extensible by new customised preference types. Preferences can be defined and aggregated by means of higher level types; for example the ``generality'' criteria discussed in the previous section is implemented in \asprin defining two \emph{subset} preferences for the derived and selected Declare constraints respectively, and combining them via a \emph{lexicographic} ordering among them. This selects Declare models with a smaller deductive closure, and a smaller number of selected constraints to resolve ties.

Describing \asprin language and the precise encoding of the optimisation problem is outside the scope of this paper (full code is available in~\cite{zenodo:experiments}). However, in abstract wording, we use two different predicates in the ASP rules to identify selected and derived Declare constraints; which are explicitly represented by means of their template name and activities as predicate arguments.
%
This enables the characterisation of the ASP models by patterns within the selected Declare constraints; e.g., by prioritising those in which specific template and/or activity names are selected or deduced. Those preferences can be combined with preferences involving the size of the Declare models to provide a fine grained and expressive ordering among the candidate models.

