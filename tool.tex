%!TEX root = ./main.tex

\section{Adding preferences to process discovery: an implementation through \asprin}
\label{sec:tool}

%At first glance it looks like the ${\textit{\sheriff}}$ function includes all what we need to generate ``preferred'' models; that is, by selecting exactly one constraint from each ${\textit{\sheriff}}(t)\neq\emptyset$ for $t\in L^-$ according to some patterns that depend on the preferences. However, that's clearly not the case because constraints are not independent: e.g., some constraints are more general than others (i.e.\ they satisfy a bigger set of traces, see Def.~\ref{def:subs}), but there is also the case in which selecting two constraints implies the validity of a third one. For example, selecting $\mathsf{precedence(a,b)}$ and $\mathsf{response(a,b)}$ would be equivalent to select $\mathsf{succession(a,b)}$ as well.
At a first glance it looks like the ${\textit{\sheriff}}$ function includes all that we need to generate ``preferred'' models. Indeed, a naive idea would be to select exactly one constraint from each ${\textit{\sheriff}}(t)\neq\emptyset$ for $t\in L^-$ according to some patterns that depend on the preferences. However, that is clearly not the case because constraints are not independent: e.g., some constraints are more general than others (i.e., they satisfy a bigger set of traces, see Def.~\ref{def:subs}), but there is also the case in which selecting two constraints implies the validity of a third one. For example, selecting $\mathsf{precedence(a,b)}$ and $\mathsf{response(a,b)}$ would be equivalent to select $\mathsf{succession(a,b)}$ as well. Therefore, the naive idea of using just the ${\textit{\sheriff}}$ function would not be enough to guarantee that the results are in line with the specified preferences. 

For this reason, we cannot use any combinatorial optimiser, but we need a system enabling some form of constraint propagation. In~\cite{deviant-tkde}, we use \ac{ASP} by leveraging the underlying rule based formalism enabling propagation, and \emph{weak constraints}\footnote{Note that these constraints are not related to the Declare constraints mentioned above, they share the name because of their relation with mathematical logic. The same meaning overloading applies to the word ``model''.} for optimisation~\cite{asp-intro,clingo}. The encoding of the optimisation problem follows the \emph{Generate and Test} \ac{ASP} paradigm where part of the rules select a candidate \ac{ASP} model (e.g., a subset of $\mathcal{C}$) and a set of constraints filters only the relevant models (e.g., those ``rejecting'' all the negative examples). Weak constraints are used to assign a preference value to any \ac{ASP} model; i.e., a violated weak constraint doesn't reject the model but assigns a penalty.
%
In~\cite{deviant-tkde}, simple weak constraints were used to implement subset based preferences; however, specifying more complex preferences between \ac{ASP} models using constraints become unmanageable and error-prone. 

To tackle this issue, in this work we exploit the \asprin tool\cite{DBLP:conf/aaai/BrewkaD0S15}, that layers upon the \emph{clingo} \ac{ASP} solver~\cite{clingo}, enabling the specification of complex preference relations through user-defined  types and their arguments. 
%
%By exploiting this flexibility we can capture the different types of preferences identified in Section~\ref{sec:example}.
%
\asprin provides a general framework for optimising qualitative and quantitative preferences in \ac{ASP}. %It allows for computing optimal answer sets of logic programs with preferences. 
While \asprin comes with a library of predefined preference types (subset, pareto, lexicographic, etc.), it is readily extensible by new customised preference types. Preferences can be defined and aggregated by means of higher level types, making \asprin the perfect tool to support the user-defined preferences that we introduced in Section \ref{sec:example}. Besides, \asprin provides a simple way to implement the ``generality'' and ``simplicity'' criteria discussed in Section \ref{sec:deviant}.


%for example we could exploit \asprin to achieve the ``generality'' criteria discussed in the previous section. Thus, an advantage of choosing \asprin is that by means of a single framework we support both the notion of user preference and the generality and simplicity concepts introduced in the previous work.  % is implemented in this in \asprin defining two \emph{subset} preferences for the derived and selected Declare constraints respectively, and combining them via a \emph{lexicographic} ordering among them. This selects Declare models with a smaller deductive closure, and a smaller number of selected constraints to resolve ties.

Describing \asprin language and the precise encoding of the optimisation problem is outside the scope of this paper (full code is available in~\cite{zenodo:experiments}). However, in abstract wording, we use two different predicates in the \ac{ASP} rules to identify selected and derived Declare constraints; which are explicitly represented by means of their template name and activities as predicate arguments.
%
This enables the characterisation of the \ac{ASP} models by patterns within the selected Declare constraints; e.g., by prioritising those in which specific template and/or activity names are selected or deduced. Those preferences can be combined with preferences involving the size of the Declare models to provide a fine grained and expressive ordering among the candidate models.
