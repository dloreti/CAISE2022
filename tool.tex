%!TEX root = ./main.tex

\section{Adding preferences to process discovery: an implementation through ASPrin}
\label{sec:tool}

From a first sight it looks like the ${\textit{\sheriff}}$ function includes all what we need to generate ``preferred'' models; that is, by selecting exactly one constraint from each ${\textit{\sheriff}}(t)\neq\emptyset$ for $t\in L^-$ according to some patterns. However, that's clearly not the case because constraints are not independent: e.g., some constraints are more general than others (i.e.\ they satisfy a bigger set of traces, see Def.~\ref{def:subs}), but there is also the case in which selecting two constraints implies the validity of a third one. For example, selecting $\mathsf{precedence(a,b)}$ and $\mathsf{response(a,b)}$ would be equivalent to select $\mathsf{succession(a,b)}$ as well.

For this reason we cannot use any combinatorial optimiser, but we need a system enabling some form of constraint propagation. In~\cite{deviant-tkde} an Answer Set Programming (ASP) has been used, by leveraging the underlying rule based formalism enabling propagation, and \emph{weak constraints}\footnote{Note that these constraints are not related to the Declare constraints mentioned above, they share the name because of their relation with mathematical logic. The same meaning overloading applies to the word ``model''.} for optimisation~\cite{asp-intro,clingo}. The encoding of the optimisation problem follows the \emph{Generate and Test} ASP paradigm where part of the rules select a candidate ASP model (e.g., a subset of $\mathcal{C}$) and a set of constraints filter only the relevant models (e.g., those ``rejecting'' all the negative examples). Weak constraints are used to assign a preference value to any ASP model; i.e., a violated weak constraint doesn't reject the model but assigns a penalty.

In~\cite{deviant-tkde}, simple weak constraints were used to implement subset based preferences; however, specifying more complex preferences between ASP models using constraints become unmanageble and error-prone. The \emph{ASPrin} tool~\cite{DBLP:conf/aaai/BrewkaD0S15} layers upon the \emph{clingo} ASP solver~\cite{clingo}, enabling the specification of complex preference relations through user-defined  types and their arguments. By leveraging this flexibility we can capture the different types of preferences we identified in Section~\ref{sec:example}.

\btext{Sergio? Illustrare i diversi tipi di preferenze, come si inseriscono nella tecnica base di deviant e l'implementazione in ASPrin. La mia proposta e' di are una sezione sola, ma si puo' anhe spezzare la parte che introduce le preferenze e la tecnica dall'implementazione specifica nel tool se riteniamo opportuno descrivere in dettaglio il tool.}

Different types of preferences
(0. subsumption, a. cardinality, b. templates, c. activities)

Noi diremmo che la subsumption la vorremmo, perché non avrebbe senso avere modelli più complicati dello stretto necessario... ma siamo sicuri? Infatti:

PROBLEMA TECNICO: ma la subsumption quando l'applichiamo? Qui siamo un po' confusi... perché applicarla sempre potrebbe dare problemi, ad esempio se la subsumption ci butta via modelli che invece sarebbero stati scelti dalle preferenze... cioè la dimensione "modello generale/modello specifico" potrebbe essere ortogonale alle preferenze: ma se sono dimensioni ortogonali, in che ordine le applichiamo?

[Questa sezione è un po' da pensare...]
